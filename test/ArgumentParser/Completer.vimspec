call vital#of('vital').unload()
let s:V = vital#of('vital')
let s:C = s:V.import('ArgumentParser.Completer')

Describe ArgumentParser.Completer
  Context .new({name}, ...)
    It should return an instance of completer
      let file_completer = s:C.new('file')
      let choice_completer = s:C.new('choice')
      Assert Equals(file_completer.__name__, 'file')
      Assert Equals(choice_completer.__name__, 'choice')
    End
  End

  Context .register({name}, {callback})
    It should register the {callback} as {name}
      function! Func() abort " {{{
        return 'Func'
      endfunction " }}}
      call s:C.register('func', function('Func'))
      let completers = s:C.get_completers()
      Assert Equals(completers.func, function('Func'))
      call s:C.unregister('func')
    End
  End

  Context .unregister({name})
    It should unregister the {name}
      function! Func() abort " {{{
        return 'Func'
      endfunction " }}}
      call s:C.register('func', function('Func'))
      let completers = s:C.get_completers()
      Assert Equals(completers.func, function('Func'))
      call s:C.unregister('func')
      let completers = s:C.get_completers()
      " compare default completer names
      Assert Equals(sort(keys(completers)), sort(['file', 'choice']))
    End
  End

  Context .get_completers()
    It should return a dictionary of completers
      let completers = s:C.get_completers()
      " compare default completer names
      Assert Equals(sort(keys(completers)), sort(['file', 'choice']))
    End
  End

  Context .get_abstract_completer()
    It should return an abstract completer instance
      let completer = s:C.get_abstract_completer()
      Assert KeyExists(completer, 'candidates')
      Assert KeyExists(completer, 'complete')
      Assert KeyExists(completer, 'gather_candidates')
    End
  End

  Context 'file' completer
    Before
      let completer = s:C.new('file', {
            \ 'base_dir': './test/ArgumentParser/misc',
            \})
    End

    Context .gather_candidates(arglead, cmdline, cursorpos, args)
      It should return a glob list of files/directories in 'base_dir'
        let candidates = completer.gather_candidates(
              \ 'B', 'A.txt', [], {}
              \)
        Assert Equals(candidates, [
              \ 'B.csv', 'B.txt',
              \])
      End
    End

    Context .complete(arglead, cmdline, cursorpos, args)
      It should return a glob list of files/directories in 'base_dir'
        let candidates = completer.complete(
              \ 'B', 'A.txt', [], {}
              \)
        Assert Equals(candidates, [
              \ 'B.csv', 'B.txt',
              \])
      End
    End
  End

  Context 'choice' completer
    Before
      let completer = s:C.new('choice', {
            \ 'choices': [
            \   'A.csv', 'A.txt',
            \   'B.csv', 'B.txt',
            \   'C.csv', 'C.txt',
            \ ],
            \})
    End

    Context .gather_candidates(arglead, cmdline, cursorpos, args)
      It should return a list of 'choices'
        let candidates = completer.gather_candidates(
              \ 'B', 'A.txt', [], {}
              \)
        Assert Equals(candidates, [
              \ 'A.csv', 'A.txt',
              \ 'B.csv', 'B.txt',
              \ 'C.csv', 'C.txt',
              \])
      End
    End

    Context .complete(arglead, cmdline, cursorpos, args)
      It should return a eliminated list of 'choices'
        let candidates = completer.complete(
              \ 'B', 'A.txt', [], {}
              \)
        Assert Equals(candidates, [
              \ 'B.csv', 'B.txt',
              \])
      End
    End
  End
End
