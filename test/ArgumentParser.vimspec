let s:V = vital#of('vital')
let s:P = s:V.import('System.Filepath')
let s:A = s:V.import('ArgumentParser')

function! Complete_choices_callback(options) abort " {{{
  return [
        \   'A.csv', 'A.txt',
        \   'B.csv', 'B.txt',
        \   'C.csv', 'C.txt',
        \]
endfunction " }}}
function! Validate_types_choices(options) abort " {{{
  return ['e', 'f', 'g']
endfunction " }}}

Describe ArgumentParser
  Context .splitargs({str})
    It return ['foo'] for 'foo'
      let ret = s:A.splitargs('foo')
      let exp = ['foo']
      Assert Equals(ret, exp)
    End
    It return ['foo', 'bar'] for 'foo bar'
      let ret = s:A.splitargs('foo bar')
      let exp = ['foo', 'bar']
      Assert Equals(ret, exp)
    End
    It return ['foo', '"bar bar"', 'hoge'] for 'foo "bar bar" hoge'
      let ret = s:A.splitargs('foo "bar bar" hoge')
      let exp = ['foo', '"bar bar"', 'hoge']
      Assert Equals(ret, exp)
    End
    It return ['"foo foo"', '"bar bar"', '"hoge hoge"'] for '"foo foo" "bar bar" "hoge hoge"'
      let ret = s:A.splitargs('"foo foo" "bar bar" "hoge hoge"')
      let exp = ['"foo foo"', '"bar bar"', '"hoge hoge"']
      Assert Equals(ret, exp)
    End
    It return ["foo", "'bar bar"', "hoge"] for "foo 'bar bar' hoge"
      let ret = s:A.splitargs("foo 'bar bar' hoge")
      let exp = ["foo", "'bar bar'", "hoge"]
      Assert Equals(ret, exp)
    End
    It return ["'foo foo'", "'bar bar'", "'hoge hoge'"] for "'foo foo' 'bar bar' 'hoge hoge'"
      let ret = s:A.splitargs("'foo foo' 'bar bar' 'hoge hoge'")
      let exp = ["'foo foo'", "'bar bar'", "'hoge hoge'"]
      Assert Equals(ret, exp)
    End
    It return ['foo="bar"', "hoge='piyo'"] for 'foo="bar" hoge=''piyo'''
      let ret = s:A.splitargs('foo="bar" hoge=''piyo''')
      let exp = ['foo="bar"', "hoge='piyo'"]
      Assert Equals(ret, exp)
    End
  End
  Context .strip_quotes({str})
    It return 'foo bar' for '"foo bar"'
      let ret = s:A.strip_quotes('"foo bar"')
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End
    It return 'foo bar' for "'foo bar'"
      let ret = s:A.strip_quotes("'foo bar'")
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End
    It return 'foo bar' for "foo bar"
      let ret = s:A.strip_quotes("foo bar")
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End
  End

  Context .complete_dummy({arglead}, {cmdline}, {cursorpos}[, {options}]) dict
    Before
      let argument = s:A.new_argument('--foo')
    End
    It return an empty list
      let candidates = call(
            \ s:A.complete_dummy,
            \ ['B', 'A.txt', []],
            \ argument
            \)
      Assert Equals(candidates, [])
    End
  End
  Context .complete_files({arglead}, {cmdline}, {cursorpos}[, {options}]) dict
    Before
      let argument = s:A.new_argument('--foo', {
            \ '__complete_files_root': s:P.realpath('test/ArgumentParser/misc'),
            \})
    End
    It return a glob list of files/directories in '__complete_files_root'
      let candidates = call(
            \ s:A.complete_files,
            \ ['B', 'A.txt', []],
            \ argument
            \)
      Assert Equals(candidates, [
            \ 'B.csv', 'B.txt',
            \])
    End
  End
  Context .complete_choices({arglead}, {cmdline}, {cursorpos}[, {options}]) dict
    Before
      let argument1 = s:A.new_argument('--foo', {
            \ 'choices': [
            \   'A.csv', 'A.txt',
            \   'B.csv', 'B.txt',
            \   'C.csv', 'C.txt',
            \ ],
            \})
      let argument2 = s:A.new_argument('--foo', {
            \ 'choices': function('Complete_choices_callback'),
            \})
    End
    It return an eliminated list of 'choices'
      " list version
      let candidates = call(
            \ s:A.complete_choices,
            \ ['B', 'A.txt', []],
            \ argument1
            \)
      Assert Equals(candidates, [
            \ 'B.csv', 'B.txt',
            \])
      " funcref version
      let candidates = call(
            \ s:A.complete_choices,
            \ ['B', 'A.txt', []],
            \ argument2
            \)
      Assert Equals(candidates, [
            \ 'B.csv', 'B.txt',
            \])
    End
  End

  Context .new([{settings}])
    It return an instance of ArgumentParser
      let ret = s:A.new()
      " property
      Assert KeyExists(ret, 'name')
      Assert KeyExists(ret, 'auto_help')
      Assert KeyExists(ret, 'description')
      Assert KeyExists(ret, 'validate_required')
      Assert KeyExists(ret, 'validate_types')
      Assert KeyExists(ret, 'validate_conflicts')
      Assert KeyExists(ret, 'validate_superordinates')
      Assert KeyExists(ret, 'validate_dependencies')
      Assert KeyExists(ret, 'validate_pattern')
      Assert KeyExists(ret, 'enable_positional_assign')
      Assert KeyExists(ret, 'complete_unknown')
      Assert KeyExists(ret, 'unknown_description')
      Assert KeyExists(ret, 'hooks')
      Assert KeyExists(ret, 'arguments')
      Assert KeyExists(ret, 'positional')
      Assert KeyExists(ret, 'required')
      Assert KeyExists(ret, 'alias')
      " method
      Assert KeyExists(ret, 'register_argument')
      Assert KeyExists(ret, 'unregister_argument')
      Assert KeyExists(ret, 'add_argument')
      Assert KeyExists(ret, 'get_conflicted_arguments')
      Assert KeyExists(ret, 'get_superordinate_arguments')
      Assert KeyExists(ret, 'get_missing_dependencies')
      Assert KeyExists(ret, 'get_positional_arguments')
      Assert KeyExists(ret, 'get_optional_arguments')
      Assert KeyExists(ret, 'get_optional_argument_aliases')
      Assert KeyExists(ret, 'parse')
      Assert KeyExists(ret, 'complete')
      Assert KeyExists(ret, 'help')
    End
    It assign a string or list {settings.description}
      let ret = s:A.new({
            \ 'description': "A\nB\nC",
            \})
      Assert Equals(ret.description, "A\nB\nC")
      let ret = s:A.new({
            \ 'description': ['A', 'B', 'C']
            \})
      Assert Equals(ret.description, "A\nB\nC")
    End
    It assign a funcref {settings.complete_unknown}
      let A = s:A
      let ret = s:A.new({ 'complete_unknown': s:A.complete_dummy })
      Assert Equals(ret.complete_unknown, A.complete_dummy)
    End
    It add 'help' argument if {settings.auto_help} is 1 (default)
      let ret = s:A.new({ 'auto_help': 1 })
      Assert KeyExists(ret.arguments, 'help')
      let ret = s:A.new()
      Assert KeyExists(ret.arguments, 'help')
    End
    It does NOT add 'help' argument if {settings.auto_help} is 0
      let ret = s:A.new({ 'auto_help': 0 })
      Assert KeyNotExists(ret.arguments, 'help')
    End
    It throws an exception if an unknown setting is specified
      let A = s:A
      Throw /Unknown setting "unknown" is specified/
            \ A.new({ 'unknown': 1 })
    End
  End
  Context .new_argument({name}[, {alias}, {description}, {options}])
    It return an argument instance
      let ret = s:A.new_argument('--foo')
      " Properties
      Assert KeyExists(ret, 'name')
      Assert KeyExists(ret, 'description')
      Assert KeyExists(ret, 'terminal')
      Assert KeyExists(ret, 'positional')
      Assert KeyExists(ret, 'required')
      Assert KeyExists(ret, 'default')
      Assert KeyExists(ret, 'alias')
      Assert KeyExists(ret, 'type')
      Assert KeyExists(ret, 'deniable')
      Assert KeyExists(ret, 'choices')
      Assert KeyExists(ret, 'pattern')
      Assert KeyExists(ret, 'conflicts')
      Assert KeyExists(ret, 'dependencies')
      Assert KeyExists(ret, 'superordinates')
      " Methods
      Assert KeyExists(ret, 'get_choices')
      Assert KeyExists(ret, 'complete')
    End
    It return an optional argument when {name} starts from - or --
      let ret1 = s:A.new_argument('-f')
      let ret2 = s:A.new_argument('--foo')
      Assert Equals(ret1.positional, 0)
      Assert Equals(ret2.positional, 0)
    End
    It return a positional argument when {name} does not starts from - or --
      let ret1 = s:A.new_argument('f')
      let ret2 = s:A.new_argument('foo')
      Assert Equals(ret1.positional, 1)
      Assert Equals(ret2.positional, 1)
    End
    It allows .new_argument({name})
      let ret = s:A.new_argument('--foo')
      Assert Equals(ret.name, 'foo')
    End
    It allows .new_argument({name}, {description})
      let ret1 = s:A.new_argument('--foo', 'description')
      let ret2 = s:A.new_argument('--foo', ['description'])
      Assert Equals(ret1.description, ['description'])
      Assert Equals(ret2.description, ['description'])
    End
    It allows .new_argument({name}, {options})
      let ret = s:A.new_argument('--foo', { 'deniable': 1 })
      Assert Equals(ret.deniable, 1)
    End
    It allows .new_argument({name}, {alias}, {description})
      let ret1 = s:A.new_argument('--foo', '-f', 'description')
      let ret2 = s:A.new_argument('--foo', '-f', ['description'])
      Assert Equals(ret1.alias, 'f')
      Assert Equals(ret2.alias, 'f')
      Assert Equals(ret1.description, ['description'])
      Assert Equals(ret2.description, ['description'])
    End
    It allows .new_argument({name}, {description}, {options})
      let ret1 = s:A.new_argument('--foo', 'description', { 'deniable': 1 })
      let ret2 = s:A.new_argument('--foo', ['description'], { 'deniable': 1 })
      Assert Equals(ret1.description, ['description'])
      Assert Equals(ret2.description, ['description'])
      Assert Equals(ret1.deniable, 1)
      Assert Equals(ret2.deniable, 1)
    End
    It automatically assign 'choice' type if {options.choice} is a funcref or non empty list
      let ret1 = s:A.new_argument('--foo', { 'choices': function('tr') })
      let ret2 = s:A.new_argument('--foo', { 'choices': ['A', 'B', 'C'] })
      let exp = s:A.types.choice
      Assert Equals(ret1.type, exp)
      Assert Equals(ret2.type, exp)
    End
    It automatically assign 'value' type if {options.pattern} is not empty
      let ret = s:A.new_argument('--foo', { 'pattern': '.*' })
      let exp = s:A.types.value
      Assert Equals(ret.type, exp)
    End
    It automatically assign 'value' type if {options.complete} is specified
      let ret = s:A.new_argument('--foo', { 'complete': s:A.complete_files })
      let exp = s:A.types.value
      Assert Equals(ret.type, exp)
    End
    It automatically assign 'value' type if the argument is a positional argument
      let ret = s:A.new_argument('foo')
      let exp = s:A.types.value
      Assert Equals(ret.type, exp)
    End
    It automatically assign 'switch' type if the argument is an optional argument
      let ret = s:A.new_argument('--foo')
      let exp = s:A.types.switch
      Assert Equals(ret.type, exp)
    End
    It automatically assign 'complete' function if {options.complete} is not specified
      let ret1 = s:A.new_argument('--foo', { 'type': s:A.types.switch })
      let ret2 = s:A.new_argument('--foo', { 'type': s:A.types.value })
      let ret3 = s:A.new_argument('--foo', { 'type': s:A.types.choice, 'choices': ['A'] })
      let ret4 = s:A.new_argument('--foo', { 'type': s:A.types.any })
      let A = s:A
      " script local function cannot be compared in Vim 7.3
      if v:version >= 704
        Assert Equals(ret1.complete, A.complete_dummy)
        Assert Equals(ret2.complete, A.complete_dummy)
        Assert Equals(ret3.complete, A.complete_choices)
        Assert Equals(ret4.complete, A.complete_dummy)
      else
        Assert Equals(string(ret1.complete), 'function(''s:complete_dummy'')')
        Assert Equals(string(ret2.complete), 'function(''s:complete_dummy'')')
        Assert Equals(string(ret3.complete), 'function(''s:complete_choices'')')
        Assert Equals(string(ret4.complete), 'function(''s:complete_dummy'')')
      endif
    End
    It throws an exception if more than 4 arguments are specified
      let A = s:A
      Throw /Too many arguments are specified/ A.new_argument(1, 2, 3, 4, 5)
    End
    It throws an exception if an unknown option is specified
      let A = s:A
      Throw /Unknown option "unknown" is specified/
            \ A.new_argument('--foo', { 'unknown': 1 })
    End
    It throws an exception if "alias" option is specified to a positional argument
      let A = s:A
      Throw /"alias" option cannot be specified to a positional argument/
            \ A.new_argument('foo', { 'alias': 'f' })
    End
    It throws an exception if "default" option is specified to a positional argument
      let A = s:A
      Throw /"default" option cannot be specified to a positional argument/
            \ A.new_argument('foo', { 'default': 'foo' })
    End
    It throws an exception if "type" option is ANY or SWITCH for a positional argument
      let A = s:A
      Throw /"type" option cannot be ANY or SWITCH for a positional argument/
            \ A.new_argument('foo', { 'type': A.types.any })
      Throw /"type" option cannot be ANY or SWITCH for a positional argument/
            \ A.new_argument('foo', { 'type': A.types.switch })
    End
    It throws an exception if "conflicts" option is specified to a positional argument
      let A = s:A
      Throw /"conflicts" option cannot be specified to a positional argument/
            \ A.new_argument('foo', { 'conflicts': ['a'] })
    End
    It throws an exception if "dependencies" option is specified to a positional argument
      let A = s:A
      Throw /"dependencies" option cannot be specified to a positional argument/
            \ A.new_argument('foo', { 'dependencies': ['a'] })
    End
    It throws an exception if "superordinates" option is specified to a positional argument
      let A = s:A
      Throw /"superordinates" option cannot be specified to a positional argument/
            \ A.new_argument('foo', { 'superordinates': ['a'] })
    End
    It throws an exception if "default" and "required" option is specified together
      let A = s:A
      Throw /"default" and "required" options cannot be specified together/
            \ A.new_argument('--foo', { 'default': 'foo', 'required': 1 })
    End
    It throws an exception if "type" is "choice" and no "choices" is specified
      let A = s:A
      Throw /"choices" option is required for CHOICE argument/
            \ A.new_argument('--foo', { 'type': A.types.choice })
    End
    It throws an exception if "pattern" is specified for SWITCH argument
      let A = s:A
      Throw /"pattern" option cannot be specified for SWITCH argument/
            \ A.new_argument('--foo', { 'type': A.types.switch, 'pattern': '.*' })
    End
  End

  Context Instance
    Before
      let parser = s:A.new()
    End
    Context .register_argument({argument})
      It register the {argument}
        let argument = s:A.new_argument('--foo')
        call parser.register_argument(argument)
        Assert KeyExists(parser.arguments, 'foo')
      End
      It assign an argument with a specified name
        call parser.register_argument(s:A.new_argument('--foo'))
        call parser.register_argument(s:A.new_argument('-b'))
        call parser.register_argument(s:A.new_argument('hoge'))
        Assert KeyExists(parser.arguments, 'foo')
        Assert KeyExists(parser.arguments, 'b')
        Assert KeyExists(parser.arguments, 'hoge')
      End
      It add an argument into 'positional' list if no leading hyphen
        call parser.register_argument(s:A.new_argument('--foo'))
        call parser.register_argument(s:A.new_argument('-b'))
        call parser.register_argument(s:A.new_argument('hoge'))
        Assert Equals(parser.positional, ['hoge'])
      End
      It add an argument into 'required' list if 'required' is specified
        call parser.register_argument(s:A.new_argument('--foo', { 'required': 1 }))
        call parser.register_argument(s:A.new_argument('-b'))
        call parser.register_argument(s:A.new_argument('hoge'))
        Assert Equals(parser.required, ['foo'])
      End
      It add an argument alias into 'alias' dictionary if 'alias' is specified
        call parser.register_argument(s:A.new_argument('--foo', { 'alias': 'f' }))
        call parser.register_argument(s:A.new_argument('-b'))
        call parser.register_argument(s:A.new_argument('hoge'))
        Assert KeyExists(parser.alias, 'f')
        Assert Equals(parser.alias.f, 'foo')
      End
      It throws an exception if the {argument} is registered
        let argument = s:A.new_argument('--foo')
        call parser.register_argument(argument)
        Throw /An argument "foo" is already registered/
              \ parser.register_argument(argument)
      End
    End
    Context .unregister_argument({argument})
      It unregister the {argument}
        let argument = s:A.new_argument('--foo')
        call parser.register_argument(argument)
        call parser.unregister_argument(argument)
        Assert KeyNotExists(parser.arguments, 'foo')
      End
      It throws an exception if the {argument} has not been registered
        let argument = s:A.new_argument('--foo')
        Throw /An argument "foo" has not been registered yet/
              \ parser.unregister_argument(argument)
      End
    End
    Context .add_argument({name}[, {alias}, {description}, {options}])
      Before
        let parser = s:A.new()
      End
      It return an argument instance
        let ret = parser.add_argument('--foo')
        let exp = s:A.new_argument('--foo')
        Assert Equals(ret, exp)
      End
      It call .register_argument({argument}) internally
        function! parser.register_argument(...) abort
          let self._register_argument_args = a:000
        endfunction
        call parser.add_argument('--foo')
        let exp = s:A.new_argument('--foo')
        Assert Equals(
              \ parser._register_argument_args,
              \ [exp]
              \)
      End
    End

    Context .get_conflicted_arguments({name}, {options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'conflicts': ['bar', 'hoge'],
              \})
        call parser.add_argument('--bar', {
              \ 'conflicts': ['foo', 'hoge'],
              \})
        call parser.add_argument('--hoge', {
              \ 'conflicts': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \ 'conflicts': ['puyo'],
              \})
        call parser.add_argument('--puyo', {
              \ 'conflicts': ['piyo'],
              \})
      End
      It return an empty list if no conflicts found
        let options = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \}
        let ret = parser.get_conflicted_arguments('foo', options)
        Assert Equals(ret, [])
        let ret = parser.get_conflicted_arguments('piyo', options)
        Assert Equals(ret, [])
      End
      It return a list of conflicted argument names if any conflicts found
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        let ret = parser.get_conflicted_arguments('foo', options)
        Assert Equals(sort(ret), ['bar', 'hoge'])
      End
    End
    Context .get_superordinate_arguments({name}, {options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'superordinates': ['foo', 'bar'],
              \})
        call parser.add_argument('piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'superordinates': ['piyo'],
              \})
      End
      It return an empty list if no superordinate argument is found
        let options = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_superordinate_arguments('hoge', options)
        Assert Equals(ret, [])
        let ret = parser.get_superordinate_arguments('puyo', options)
        Assert Equals(ret, [])
      End
      It return a list of superordinate arguments if any
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        let ret = parser.get_superordinate_arguments('hoge', options)
        Assert Equals(sort(ret), ['bar', 'foo'])
      End
    End
    Context .get_missing_dependencies({name}, {options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'dependencies': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'dependencies': ['piyo'],
              \})
      End
      It return an empty list if all dependencies are exists
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_missing_dependencies('foo', options)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('bar', options)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('hoge', options)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('piyo', options)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('puyo', options)
        Assert Equals(ret, [])
      End
      It return a list of conflicted argument names if any conflicts found
        let options = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_missing_dependencies('hoge', options)
        Assert Equals(sort(ret), ['bar', 'foo'])
        let ret = parser.get_missing_dependencies('puyo', options)
        Assert Equals(sort(ret), ['piyo'])
      End
    End

    Context .parse({bang}, {range}[, {q-args}, {options}])
      Before
        let parser = s:A.new()
        let parser._ncalls = {
              \ '_parse_args': 0,
              \ '_regulate_options': 0,
              \ '_validate_options': 0,
              \}
        function! parser._parse_args(...)
          let self._ncalls._parse_args += 1
          return {}
        endfunction
        function! parser._regulate_options(...)
          let self._ncalls._regulate_options += 1
        endfunction
        function! parser._validate_options(...)
          let self._ncalls._validate_options += 1
        endfunction
      End
      It call '_parse_args'
        let ncalls = parser._ncalls._parse_args
        call parser.parse('', {})
        Assert Equals(parser._ncalls._parse_args, ncalls + 1)
      End
      It call '_regulate_options'
        let ncalls = parser._ncalls._regulate_options
        call parser.parse('', {})
        Assert Equals(parser._ncalls._regulate_options, ncalls + 1)
      End
      It call '_validate_options'
        let ncalls = parser._ncalls._validate_options
        call parser.parse('', {})
        Assert Equals(parser._ncalls._validate_options, ncalls + 1)
      End
    End
    Context ._parse_args({args}[, {options}])
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'deniable': 1 })
        call parser.add_argument('--bar', { 'alias': 'b' })
        call parser.add_argument('-H')
        call parser.add_argument('piyo')
        call parser.add_argument('puyo')
        call parser.add_argument('--terminal', { 'terminal': 1 })
        call parser.add_argument('--on_default', { 'on_default': 'hello' })
      End
      It correctly parse optional arguments (list)
        let ret = parser._parse_args(['--foo', '-b', '-H=hoge'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--foo', '-b', '-H=hoge'],
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'H': 'hoge',
              \}
        Assert Equals(ret, exp)
      End
      It correctly parse positional arguments (list)
        let ret = parser._parse_args(['hi', '"hello world"'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['hi', '"hello world"'],
              \ 'piyo': 'hi',
              \ 'puyo': 'hello world',
              \}
        Assert Equals(ret, exp)
      End
      It correctly parse arguments (list)
        let ret = parser._parse_args(['hi', '--foo', '-b', '"hello world"', '--unknown', 'unk'])
        let exp = {
              \ '__unknown__': ['--unknown', 'unk'],
              \ '__args__': ['hi', '--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'piyo': 'hi',
              \ 'puyo': 'hello world',
              \}
        Assert Equals(ret, exp)
      End
      It correctly parse '--foo foo' value assignment if enable_positional_assign is defined (list)
        let parser.enable_positional_assign = 1
        let ret = parser._parse_args(['--foo', 'bar'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--foo', 'bar'],
              \ 'foo': 'bar',
              \}
        Assert Equals(ret, exp)
      End
      It correctly parse '--no-foo' if the argument is deniable (list)
        let ret = parser._parse_args(['--no-foo'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--no-foo'],
              \ 'foo': 0,
              \}
        Assert Equals(ret, exp)
      End
      It abort parse when a terminal argument is found (list)
        let ret = parser._parse_args(['hi', '--terminal', '--foo', '-b', '"hello world"', '--unknown', 'unk'])
        let exp = {
              \ '__terminated__': 1,
              \ '__unknown__': ['--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ '__args__': ['hi', '--terminal', '--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ 'terminal': 1,
              \ 'piyo': 'hi',
              \}
        Assert Equals(ret, exp)

        let ret = parser._parse_args(['hi', '--', '--foo', '-b', '"hello world"', '--unknown', 'unk'])
        let exp = {
              \ '__terminated__': 1,
              \ '__unknown__': ['--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ '__args__': ['hi', '--', '--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ 'piyo': 'hi',
              \}
        Assert Equals(ret, exp)
      End
      It correctly parse a partial input like '--foo -'
        let ret = parser._parse_args(['--foo', '-'])
        let exp = {
              \ '__unknown__': ['-'],
              \ '__args__': ['--foo', '-'],
              \ 'foo': 1,
              \}
        Assert Equals(ret, exp)
      End
      It correctly apply 'on_default' value when no value is specified
        let ret = parser._parse_args(['--on_default'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--on_default'],
              \ 'on_default': 'hello',
              \}
        Assert Equals(ret, exp)
      End
    End
    Context ._validate_options({options})
      Before
        let parser = s:A.new()
        let parser._ncalls = {
              \ '_validate_required': 0,
              \ '_validate_types': 0,
              \ '_validate_conflicts': 0,
              \ '_validate_superordinates': 0,
              \ '_validate_dependencies': 0,
              \ '_validate_pattern': 0,
              \ 'pre_validation': 0,
              \ 'post_validation': 0,
              \}
        function! parser._validate_required(...)
          let self._ncalls._validate_required += 1
        endfunction
        function! parser._validate_types(...)
          let self._ncalls._validate_types += 1
        endfunction
        function! parser._validate_conflicts(...)
          let self._ncalls._validate_conflicts += 1
        endfunction
        function! parser._validate_superordinates(...)
          let self._ncalls._validate_superordinates += 1
        endfunction
        function! parser._validate_dependencies(...)
          let self._ncalls._validate_dependencies += 1
        endfunction
        function! parser._validate_pattern(...)
          let self._ncalls._validate_pattern += 1
        endfunction
        " user define hooks
        function! parser.hooks.pre_validation(...)
          let self._ncalls.pre_validation += 1
          return {}
        endfunction
        function! parser.hooks.post_validation(...)
          let self._ncalls.post_validation += 1
          return {}
        endfunction
      End
      It NOT call '_validate_required' if 'validate_required' is 0
        let parser.validate_required = 0
        Assert Equals(parser._ncalls._validate_required, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_required, 0)
      End
      It call '_validate_required' if 'validate_required' is 1
        let parser.validate_required = 1
        Assert Equals(parser._ncalls._validate_required, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_required, 1)
      End
      It NOT call '_validate_types' if 'validate_required' is 0
        let parser.validate_types = 0
        Assert Equals(parser._ncalls._validate_types, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_types, 0)
      End
      It call '_validate_types' if 'validate_required' is 1
        let parser.validate_types = 1
        Assert Equals(parser._ncalls._validate_types, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_types, 1)
      End
      It NOT call '_validate_conflicts' if 'validate_required' is 0
        let parser.validate_conflicts = 0
        Assert Equals(parser._ncalls._validate_conflicts, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_conflicts, 0)
      End
      It call '_validate_conflicts' if 'validate_required' is 1
        let parser.validate_conflicts = 1
        Assert Equals(parser._ncalls._validate_conflicts, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_conflicts, 1)
      End
      It NOT call '_validate_superordinates' if 'validate_required' is 0
        let parser.validate_superordinates = 0
        Assert Equals(parser._ncalls._validate_superordinates, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_superordinates, 0)
      End
      It call '_validate_superordinates' if 'validate_required' is 1
        let parser.validate_superordinates = 1
        Assert Equals(parser._ncalls._validate_superordinates, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_superordinates, 1)
      End
      It NOT call '_validate_dependencies' if 'validate_required' is 0
        let parser.validate_dependencies = 0
        Assert Equals(parser._ncalls._validate_dependencies, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_dependencies, 0)
      End
      It call '_validate_dependencies' if 'validate_required' is 1
        let parser.validate_dependencies = 1
        Assert Equals(parser._ncalls._validate_dependencies, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_dependencies, 1)
      End
      It NOT call '_validate_pattern' if 'validate_required' is 0
        let parser.validate_pattern = 0
        Assert Equals(parser._ncalls._validate_pattern, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_pattern, 0)
      End
      It call '_validate_pattern' if 'validate_required' is 1
        let parser.validate_pattern = 1
        Assert Equals(parser._ncalls._validate_pattern, 0)
        call parser._validate_options({})
        Assert Equals(parser._ncalls._validate_pattern, 1)
      End
    End
    Context ._validate_required({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'required': 1,
              \})
        call parser.add_argument('--bar', {
              \ 'alias': 'b',
              \ 'required': 1,
              \})
        call parser.add_argument('-H', {
              \})
        call parser.add_argument('piyo', {
              \ 'required': 1,
              \})
        call parser.add_argument('puyo', {
              \})
      End
      It does nothing if all requirements are specified
        let options = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \ 'bar': 'hello',
              \}
        call parser._validate_required(options)
      End
      It throws an exception if there are any missing requirements
        let options = {
              \ 'foo': 1,
              \ 'H': 1,
              \}
        Throw /Argument "bar" is required but not specified/
              \ parser._validate_required(options)
      End
    End
    Context ._validate_types({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'type': s:A.types.any,
              \})
        call parser.add_argument('--bar', {
              \ 'type': s:A.types.value,
              \})
        call parser.add_argument('--hoge', {
              \ 'type': s:A.types.switch,
              \})
        call parser.add_argument('--piyo', {
              \ 'type': s:A.types.choice,
              \ 'choices': ['a', 'b', 'c'],
              \})
        call parser.add_argument('--puyo', {
              \ 'type': s:A.types.choice,
              \ 'choices': function('Validate_types_choices'),
              \})
      End
      It does nothing if all arguments are correctly specified
        let options = {
              \ 'foo': 1,
              \ 'bar': 'bar',
              \ 'hoge': 1,
              \ 'piyo': 'a',
              \}
        call parser._validate_types(options)
      End
      It throws an exception if no value is specified to VALUE argument
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        Throw /Argument "bar" is VALUE argument but no value is specified/
              \ parser._validate_types(options)
      End
      It throws an exception if value is specified to SWITCH argument
        let options = {
              \ 'foo': 1,
              \ 'bar': 'bar',
              \ 'hoge': 'hoge',
              \}
        Throw /Argument "hoge" is SWITCH argument but "hoge" is specified/
              \ parser._validate_types(options)
      End
      It throws an exception if no value is specified to CHOICE argument
        let options = {
              \ 'piyo': 1,
              \}
        Throw /Argument "piyo" is CHOICE argument but no value is specified/
              \ parser._validate_types(options)
      End
      It throws an exception if an invalid value is specified to CHOICE argument
        let options = {
              \ 'piyo': 'hogehoge',
              \}
        Throw /Argument "piyo" is CHOICE argument but an invalid value "hogehoge" is specified/
              \ parser._validate_types(options)

        let options = {
              \ 'puyo': 'hogehoge',
              \}
        Throw /Argument "puyo" is CHOICE argument but an invalid value "hogehoge" is specified/
              \ parser._validate_types(options)
      End
    End
    Context ._validate_conflicts({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'conflicts': ['bar', 'hoge'],
              \})
        call parser.add_argument('--bar', {
              \ 'conflicts': ['foo', 'hoge'],
              \})
        call parser.add_argument('--hoge', {
              \ 'conflicts': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \ 'conflicts': ['puyo'],
              \})
        call parser.add_argument('--puyo', {
              \ 'conflicts': ['piyo'],
              \})
      End
      It deos nothing if no conflicts found
        let options = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \}
        call parser._validate_conflicts(options)
      End
      It throws an exception if one of an argument conflict with another
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \}
        Throw /Argument "foo" conflicts with an argument "bar"/
              \ parser._validate_conflicts(options)
      End
    End
    Context ._validate_superordinates({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'superordinates': ['foo', 'bar'],
              \})
        call parser.add_argument('piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'superordinates': ['piyo'],
              \})
      End
      It does nothing if one of superordinates is specified
        let options = {
              \ 'foo': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        call parser._validate_superordinates(options)
      End
      It throws an exception if no superordinate is specified
        let options = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        Throw /No superordinate argument(s) of "hoge" is specified/
              \ parser._validate_superordinates(options)
      End
    End
    Context ._validate_dependencies({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'dependencies': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'dependencies': ['piyo'],
              \})
      End
      It does nothing if all dependencies are exists
        let options = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        call parser._validate_dependencies(options)
      End
      It throws an exception if any dependencies is missing
        let options = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        Throw /Argument "foo" is required for an argument "hoge" but missing/
              \ parser._validate_dependencies(options)
      End
    End
    Context ._validate_pattern({options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'pattern': '^\d\d\d-\d\d\d\d$'
              \})
      End
      It does nothing if the value follow the specified pattern
        let options = {
              \ 'foo': '000-0000',
              \}
        call parser._validate_pattern(options)
      End
      It throws an exception if the value does not follow the specified pattern
        let options = {
              \ 'foo': '00-0000',
              \}
        Throw /A value of argument "foo" does not follow a specified pattern "\^\\d\\d\\d-\\d\\d\\d\\d\$"/
              \ parser._validate_pattern(options)
      End
    End

    Context .complete({arglead}, {cmdline}, {cursorpos}[, {options}])
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'choices': ['foo', 'foobar', 'bar', 'hoge'] })
        call parser.add_argument('--bar', { 'choices': ['hello', 'good', 'bye'] })
        call parser.add_argument('good')
        call parser.add_argument('bye')
        let parser._ncalls = {
              \ '_parse_args': 0,
              \ '_complete_unknown': 0,
              \ '_complete_optional_argument_value': 0,
              \ '_complete_optional_argument': 0,
              \ '_complete_positional_argument_value': 0,
              \}
        function! parser._parse_args(...)
          let self._ncalls._parse_args += 1
          return {}
        endfunction
        function! parser.complete_unknown(...)
          let self._ncalls._complete_unknown += 1
        endfunction
        function! parser._complete_optional_argument_value(...)
          let self._ncalls._complete_optional_argument_value += 1
        endfunction
        function! parser._complete_optional_argument(...)
          let self._ncalls._complete_optional_argument += 1
        endfunction
        function! parser._complete_positional_argument_value(...)
          let self._ncalls._complete_positional_argument_value += 1
        endfunction
      End
      It call '_parse_args'
        let ncalls = parser._ncalls._parse_args
        call parser.complete('--foo=', '--foo=', [], {})
        Assert Equals(parser._ncalls._parse_args, ncalls + 1)
      End
      It call '_complete_optional_argument_value' if '--foo=' is specified
        Assert Equals(parser._ncalls._complete_optional_argument_value, 0)
        call parser.complete('--foo=', '--foo=', [], {})
        Assert Equals(parser._ncalls._complete_optional_argument_value, 1)
      End
      It call '_complete_optional_argument' if '--f' is specified
        Assert Equals(parser._ncalls._complete_optional_argument, 0)
        call parser.complete('--f', '--f', [], {})
        Assert Equals(parser._ncalls._complete_optional_argument, 1)
      End
      It call '_complete_optional_argument' if 'f' is specified
        Assert Equals(parser._ncalls._complete_positional_argument_value, 0)
        call parser.complete('f', 'f', [], {})
        Assert Equals(parser._ncalls._complete_positional_argument_value, 1)
      End
      It call 'complete_unknown' if '__terminated__' is specified to {options}
        Assert Equals(parser._ncalls._complete_unknown, 0)
        call parser.complete('f', 'f', [], { '__terminated__': 1})
        Assert Equals(parser._ncalls._complete_unknown, 1)
      End
    End
    Context ._complete_optional_argument_value({arglead}, {cmdline}, {cursorpos}, {options})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'choices': ['foo', 'foobar', 'bar', 'hoge'] })
        call parser.add_argument('--bar', { 'choices': ['hello', 'good', 'bye'] })
      End
      It return all posible candidates of a specified argument
        let candidates = parser._complete_optional_argument_value(
              \ '--foo=',
              \ '--foo=',
              \ [],
              \ { 'foo': '' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo=foo', '--foo=foobar', '--foo=bar', '--foo=hoge']),
              \)
      End
      It return eliminated candidates of a specified argument if a part of value is specified
        let candidates = parser._complete_optional_argument_value(
              \ '--foo=fo',
              \ '--foo=',
              \ [],
              \ { 'foo': '' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo=foo', '--foo=foobar']),
              \)
      End
    End
    Context ._complete_optional_argument({arglead}, {cmdline}, {cursorpos}, {options})
      Before
        let parser = s:A.new({ 'auto_help': 0 })
        call parser.add_argument('--foo')
        call parser.add_argument('--foobar', { 'alias': 'f' })
        call parser.add_argument('--bar', { 'conflicts': ['hoge'] })
        call parser.add_argument('--hoge', { 'conflicts': ['bar'] })
        call parser.add_argument('--piyo')
        call parser.add_argument('--puyo', { 'superordinates': ['piyo'] })
        call parser.add_argument('hello')
      End
      It return all posible arguments
        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { 'bar': 1 },
              \)
        " --bar is already specified thus not included
        " --hoge conflicts with --bar thus not included
        " --puyo require --piyo thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--piyo']),
              \)

        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { },
              \)
        " --puyo require --piyo thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--piyo', '--bar', '--hoge']),
              \)

        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { 'piyo': 1 },
              \)
        " --puyo is already specified thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--puyo', '--bar', '--hoge']),
              \)
      End
      It return eliminated arguments if a part of argument name is specified
        let candidates = parser._complete_optional_argument(
              \ '--fo',
              \ '--fo',
              \ [],
              \ {},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar']),
              \)
      End
    End
    Context ._complete_positional_argument_value({arglead}, {cmdline}, {cursorpos}, {options})
      Before
        let parser = s:A.new({ 'auto_help': 0 })
        call parser.add_argument('foo', { 'choices': ['aa', 'ab', 'ac', 'bb', 'bc', 'bd'] })
        call parser.add_argument('bar', { 'choices': ['e', 'f', 'g'] })
      End
      It return all possible values of a corresponding positional argument
        let candidates = parser._complete_positional_argument_value(
              \ '',
              \ 'ArgumentParse ',
              \ 15,
              \ {},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['aa', 'ab', 'ac', 'bb', 'bc', 'bd']),
              \)

        let candidates = parser._complete_positional_argument_value(
              \ '',
              \ 'ArgumentParse aa ',
              \ 18,
              \ { 'foo': 'aa' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['e', 'f', 'g']),
              \)
      End
      It return eliminated values if a part of positional argument value is specified
        let candidates = parser._complete_positional_argument_value(
              \ 'b',
              \ 'ArgumentParse b',
              \ 16,
              \ {},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['bb', 'bc', 'bd']),
              \)
      End
    End

    Context .help()
      Before
        let parser = s:A.new({
              \ 'name': 'Foo',
              \ 'description': 'bar bar bar',
              \ 'unknown_description': 'hoge hoge',
              \ 'auto_help': 0,
              \})
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It return a help
        let ret = parser.help()
        let exp = [
              \ ':Foo [--foo] [--bar] [alpha] [--hoge[=HOGE]] [--piyo=PIYO] [--puyo={PUYO}] [--[no-]papa] --mama beta -- hoge hoge',
              \ '',
              \ 'bar bar bar',
              \ '',
              \ 'Positional arguments:',
              \ '  alpha              alpha definition',
              \ '  beta               beta definition (*)',
              \ '',
              \ 'Optional arguments:',
              \ '      --foo          foo definition',
              \ '  -b, --bar          bar definition',
              \ '      --hoge[=HOGE]  hoge definition',
              \ '      --piyo=PIYO    piyo definition',
              \ '      --puyo={PUYO}  puyo definition',
              \ '      --[no-]papa    papa definition',
              \ '      --mama         mama definition (*)',
              \]
        Assert Equals(ret, join(exp, "\n"))
      End
    End
    Context ._help_optional_argument({arg})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It return [{definition], {description}] list of a specified argument
        let ret = parser._help_optional_argument(parser.arguments['foo'])
        Assert Equals(ret[0], '    --foo')
        Assert Equals(ret[1], 'foo definition')

        let ret = parser._help_optional_argument(parser.arguments['bar'])
        Assert Equals(ret[0], '-b, --bar')
        Assert Equals(ret[1], 'bar definition')

        let ret = parser._help_optional_argument(parser.arguments['hoge'])
        Assert Equals(ret[0], '    --hoge[=HOGE]')
        Assert Equals(ret[1], 'hoge definition')

        let ret = parser._help_optional_argument(parser.arguments['piyo'])
        Assert Equals(ret[0], '    --piyo=PIYO')
        Assert Equals(ret[1], 'piyo definition')

        let ret = parser._help_optional_argument(parser.arguments['puyo'])
        Assert Equals(ret[0], '    --puyo={PUYO}')
        Assert Equals(ret[1], 'puyo definition')

        let ret = parser._help_optional_argument(parser.arguments['papa'])
        Assert Equals(ret[0], '    --[no-]papa')
        Assert Equals(ret[1], 'papa definition')

        let ret = parser._help_optional_argument(parser.arguments['mama'])
        Assert Equals(ret[0], '    --mama')
        Assert Equals(ret[1], 'mama definition (*)')
      End
    End
    Context ._help_positional_argument({arg})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It return [{definition], {description}] list of a specified argument
        let ret = parser._help_positional_argument(parser.arguments['alpha'])
        Assert Equals(ret[0], 'alpha')
        Assert Equals(ret[1], 'alpha definition')
        let ret = parser._help_positional_argument(parser.arguments['beta'])
        Assert Equals(ret[0], 'beta')
        Assert Equals(ret[1], 'beta definition (*)')
      End
    End
  End
End
