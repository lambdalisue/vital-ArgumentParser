call vital#of('vital').unload()
let s:V = vital#of('vital')
let s:A = s:V.import('ArgumentParser')

Describe ArgumentParser
  Context .splitargs({str})
    It should return ['foo'] for 'foo'
      let ret = s:A.splitargs('foo')
      let exp = ['foo']
      Assert Equals(ret, exp)
    End

    It should return ['foo', 'bar'] for 'foo bar'
      let ret = s:A.splitargs('foo bar')
      let exp = ['foo', 'bar']
      Assert Equals(ret, exp)
    End

    It should return ['foo', '"bar bar"', 'hoge'] for 'foo "bar bar" hoge'
      let ret = s:A.splitargs('foo "bar bar" hoge')
      let exp = ['foo', '"bar bar"', 'hoge']
      Assert Equals(ret, exp)
    End

    It should return ['"foo foo"', '"bar bar"', '"hoge hoge"'] for '"foo foo" "bar bar" "hoge hoge"'
      let ret = s:A.splitargs('"foo foo" "bar bar" "hoge hoge"')
      let exp = ['"foo foo"', '"bar bar"', '"hoge hoge"']
      Assert Equals(ret, exp)
    End

    It should return ["foo", "'bar bar"', "hoge"] for "foo 'bar bar' hoge"
      let ret = s:A.splitargs("foo 'bar bar' hoge")
      let exp = ["foo", "'bar bar'", "hoge"]
      Assert Equals(ret, exp)
    End

    It should return ["'foo foo'", "'bar bar'", "'hoge hoge'"] for "'foo foo' 'bar bar' 'hoge hoge'"
      let ret = s:A.splitargs("'foo foo' 'bar bar' 'hoge hoge'")
      let exp = ["'foo foo'", "'bar bar'", "'hoge hoge'"]
      Assert Equals(ret, exp)
    End

    It should return ['foo="bar"', "hoge='piyo'"] for 'foo="bar" hoge=''piyo'''
      let ret = s:A.splitargs('foo="bar" hoge=''piyo''')
      let exp = ['foo="bar"', "hoge='piyo'"]
      Assert Equals(ret, exp)
    End
  End

  Context .strip_quotes({str})
    It should return 'foo bar' for '"foo bar"'
      let ret = s:A.strip_quotes('"foo bar"')
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End

    It should return 'foo bar' for "'foo bar'"
      let ret = s:A.strip_quotes("'foo bar'")
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End

    It should return 'foo bar' for "foo bar"
      let ret = s:A.strip_quotes("foo bar")
      let exp = 'foo bar'
      Assert Equals(ret, exp)
    End
  End

  Context .new([{options}])
    It should return an instance of ArgumentParser
      let ret = s:A.new()
      " property
      Assert KeyExists(ret, 'arguments')
      Assert KeyExists(ret, 'positional')
      Assert KeyExists(ret, 'required')
      Assert KeyExists(ret, 'alias')
      " method
      Assert KeyExists(ret, 'add_argument')
    End
  End

  Context Instance
    Context .add_argument({name}[, {alias}, {description}, {options}])
      Before
        let parser = s:A.new()
      End
      It should return an argument instance
        let ret = parser.add_argument('--foo')
        Assert KeyExists(ret, 'name')
        Assert KeyExists(ret, 'positional')
        Assert KeyExists(ret, 'required')
        Assert KeyExists(ret, 'default')
        Assert KeyExists(ret, 'alias')
        Assert KeyExists(ret, 'type')
        Assert KeyExists(ret, 'deniable')
        Assert KeyExists(ret, 'choices')
        Assert KeyExists(ret, 'pattern')
        Assert KeyExists(ret, 'conflicts')
        Assert KeyExists(ret, 'superordinates')
        Assert KeyExists(ret, 'dependencies')
        Assert KeyExists(ret, 'completer')
        Assert KeyExists(ret, 'terminal')

        let ret = parser.add_argument('--bar', 'description of bar')
        Assert Equals(ret.description, 'description of bar')

        let ret = parser.add_argument('--hoge', '-h', 'description of hoge')
        Assert Equals(ret.alias, 'h')
      End
      It should assign an argument with a specified name
        call parser.add_argument('--foo')
        call parser.add_argument('-b')
        call parser.add_argument('hoge')
        Assert KeyExists(parser.arguments, 'foo')
        Assert KeyExists(parser.arguments, 'b')
        Assert KeyExists(parser.arguments, 'hoge')
      End
      It should add an argument into 'positional' list if no leading hyphen
        call parser.add_argument('--foo')
        call parser.add_argument('-b')
        call parser.add_argument('hoge')
        Assert Equals(parser.positional, ['hoge'])
      End
      It should add an argument into 'required' list if 'required' is specified
        call parser.add_argument('--foo', { 'required': 1 })
        call parser.add_argument('-b')
        call parser.add_argument('hoge')
        Assert Equals(parser.required, ['foo'])
      End
      It should add an argument alias into 'alias' dictionary if 'alias' is specified
        call parser.add_argument('--foo', { 'alias': 'f' })
        call parser.add_argument('-b')
        call parser.add_argument('hoge')
        Assert KeyExists(parser.alias, 'f')
        Assert Equals(parser.alias.f, 'foo')
      End
      It should raise an exception if "alias" option is specified to a positional argument
        Throw parser.add_argument('foo', { 'alias': 'f' }), '"alias" option cannot be specified'
      End
      It should raise an exception if "default" option is specified to a positional argument
        Throw parser.add_argument('foo', { 'default': 'foo' }), '"default" option cannot be specified'
      End
      It should raise an exception if "type" option is ANY for a positional argument
        let types = s:A.types
        Throw parser.add_argument('foo', { 'type': types.any }), '"type" option cannot be ANY or SWITCH'
      End
      It should raise an exception if "type" option is SWITCH for a positional argument
        let types = s:A.types
        Throw parser.add_argument('foo', { 'type': types.switch }), '"type" option cannot be ANY or SWITCH'
      End
      It should raise an exception if "conflicts" option is specified to a positional argument
        let switch = s:A.types.switch
        Throw parser.add_argument('foo', { 'conflicts': ['a'] }), '"conflicts" option cannot be specified'
      End
      It should raise an exception if "dependencies" option is specified to a positional argument
        let switch = s:A.types.switch
        Throw parser.add_argument('foo', { 'dependencies': ['a'] }), '"dependencies" option cannot be specified'
      End
      It should raise an exception if "superordinates" option is specified to a positional argument
        let switch = s:A.types.switch
        Throw parser.add_argument('foo', { 'superordinates': ['a'] }), '"superordinates" option cannot be specified'
      End
      It should raise an exception if "default" and "required" option is specified together
        Throw parser.add_argument('foo', { 'default': 'foo', 'required': 1 }), '"default" and "required" option cannot be specified'
      End
      It should raise an exception if "type" is "choice" and no "choices" is specified
        Throw parser.add_argument('foo', { 'type': 'choice' }), '"type" is specified to "choice" but no "choices" is specified'
      End
      It should raise an exception if "pattern" is specified for SWITCH argument
        let types = s:A.types
        Throw parser.add_argument('foo', { 'type': types.switch, 'pattern': 'hello' }), '"pattern" option cannot be specified'
      End
    End
    Context .get_conflicted_arguments({name}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'conflicts': ['bar', 'hoge'],
              \})
        call parser.add_argument('--bar', {
              \ 'conflicts': ['foo', 'hoge'],
              \})
        call parser.add_argument('--hoge', {
              \ 'conflicts': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \ 'conflicts': ['puyo'],
              \})
        call parser.add_argument('--puyo', {
              \ 'conflicts': ['piyo'],
              \})
      End
      It should return an empty list if no conflicts found
        let opts = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \}
        let ret = parser.get_conflicted_arguments('foo', opts)
        Assert Equals(ret, [])
        let ret = parser.get_conflicted_arguments('piyo', opts)
        Assert Equals(ret, [])
      End
      It should return a list of conflicted argument names if any conflicts found
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        let ret = parser.get_conflicted_arguments('foo', opts)
        Assert Equals(sort(ret), ['bar', 'hoge'])
      End
    End
    Context .get_superordinate_arguments({name}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'superordinates': ['foo', 'bar'],
              \})
        call parser.add_argument('piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'superordinates': ['piyo'],
              \})
      End
      It should return an empty list if no superordinate argument is found
        let opts = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_superordinate_arguments('hoge', opts)
        Assert Equals(ret, [])
        let ret = parser.get_superordinate_arguments('puyo', opts)
        Assert Equals(ret, [])
      End
      It should return a list of superordinate arguments if any
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        let ret = parser.get_superordinate_arguments('hoge', opts)
        Assert Equals(sort(ret), ['bar', 'foo'])
      End
    End
    Context .get_missing_dependencies({name}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'dependencies': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'dependencies': ['piyo'],
              \})
      End
      It should return an empty list if all dependencies are exists
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_missing_dependencies('foo', opts)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('bar', opts)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('hoge', opts)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('piyo', opts)
        Assert Equals(ret, [])
        let ret = parser.get_missing_dependencies('puyo', opts)
        Assert Equals(ret, [])
      End
      It should return a list of conflicted argument names if any conflicts found
        let opts = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        let ret = parser.get_missing_dependencies('hoge', opts)
        Assert Equals(sort(ret), ['bar', 'foo'])
        let ret = parser.get_missing_dependencies('puyo', opts)
        Assert Equals(sort(ret), ['piyo'])
      End
    End

    Context .parse({bang}, {range}, ...)
      Before
        let parser = s:A.new()
        let parser._ncalls = {
              \ '_parse_args': 0,
              \ '_regulate_opts': 0,
              \ '_validate_opts': 0,
              \}
        function! parser._parse_args(...)
          let self._ncalls._parse_args += 1
          return {}
        endfunction
        function! parser._regulate_opts(...)
          let self._ncalls._regulate_opts += 1
        endfunction
        function! parser._validate_opts(...)
          let self._ncalls._validate_opts += 1
        endfunction
      End
      It should call '_parse_args'
        let ncalls = parser._ncalls._parse_args
        call parser.parse('', {})
        Assert Equals(parser._ncalls._parse_args, ncalls + 1)
      End
      It should call '_regulate_opts'
        let ncalls = parser._ncalls._regulate_opts
        call parser.parse('', {})
        Assert Equals(parser._ncalls._regulate_opts, ncalls + 1)
      End
      It should call '_validate_opts'
        let ncalls = parser._ncalls._validate_opts
        call parser.parse('', {})
        Assert Equals(parser._ncalls._validate_opts, ncalls + 1)
      End
    End
    Context ._parse_args({args}[, {opts}])
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'deniable': 1 })
        call parser.add_argument('--bar', { 'alias': 'b' })
        call parser.add_argument('-H')
        call parser.add_argument('piyo')
        call parser.add_argument('puyo')
        call parser.add_argument('--terminal', { 'terminal': 1 })
      End
      It should correctly parse optional arguments (list)
        let ret = parser._parse_args(['--foo', '-b', '-H=hoge'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--foo', '-b', '-H=hoge'],
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'H': 'hoge',
              \}
        Assert Equals(ret, exp)
      End
      It should correctly parse positional arguments (list)
        let ret = parser._parse_args(['hi', '"hello world"'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['hi', '"hello world"'],
              \ 'piyo': 'hi',
              \ 'puyo': 'hello world',
              \}
        Assert Equals(ret, exp)
      End
      It should correctly parse arguments (list)
        let ret = parser._parse_args(['hi', '--foo', '-b', '"hello world"', '--unknown', 'unk'])
        let exp = {
              \ '__unknown__': ['--unknown', 'unk'],
              \ '__args__': ['hi', '--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'piyo': 'hi',
              \ 'puyo': 'hello world',
              \}
        Assert Equals(ret, exp)
      End
      It should correctly parse '--foo foo' value assignment if enable_positional_assign is defined (list)
        let parser.enable_positional_assign = 1
        let ret = parser._parse_args(['--foo', 'bar'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--foo', 'bar'],
              \ 'foo': 'bar',
              \}
        Assert Equals(ret, exp)
      End
      It should correctly parse '--no-foo' if the argument is deniable (list)
        let ret = parser._parse_args(['--no-foo'])
        let exp = {
              \ '__unknown__': [],
              \ '__args__': ['--no-foo'],
              \ 'foo': 0,
              \}
        Assert Equals(ret, exp)
      End
      It should abort parse when a terminal argument is found (list)
        let ret = parser._parse_args(['hi', '--terminal', '--foo', '-b', '"hello world"', '--unknown', 'unk'])
        let exp = {
              \ '__unknown__': ['--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ '__args__': ['hi', '--terminal', '--foo', '-b', '"hello world"', '--unknown', 'unk'],
              \ 'terminal': 1,
              \ 'piyo': 'hi',
              \}
        Assert Equals(ret, exp)
      End
      It should correctly parse a partial input like '--foo -'
        let ret = parser._parse_args(['--foo', '-'])
        let exp = {
              \ '__unknown__': ['-'],
              \ '__args__': ['--foo', '-'],
              \ 'foo': 1,
              \}
        Assert Equals(ret, exp)
      End
    End
    Context ._validate_opts({opts})
      Before
        let parser = s:A.new()
        let parser._ncalls = {
              \ '_validate_required': 0,
              \ '_validate_types': 0,
              \ '_validate_conflicts': 0,
              \ '_validate_superordinates': 0,
              \ '_validate_dependencies': 0,
              \ '_validate_pattern': 0,
              \ 'pre_validation': 0,
              \ 'post_validation': 0,
              \}
        function! parser._validate_required(...)
          let self._ncalls._validate_required += 1
        endfunction
        function! parser._validate_types(...)
          let self._ncalls._validate_types += 1
        endfunction
        function! parser._validate_conflicts(...)
          let self._ncalls._validate_conflicts += 1
        endfunction
        function! parser._validate_superordinates(...)
          let self._ncalls._validate_superordinates += 1
        endfunction
        function! parser._validate_dependencies(...)
          let self._ncalls._validate_dependencies += 1
        endfunction
        function! parser._validate_pattern(...)
          let self._ncalls._validate_pattern += 1
        endfunction
        " user define hooks
        function! parser.hooks.pre_validation(...)
          let self._ncalls.pre_validation += 1
          return {}
        endfunction
        function! parser.hooks.post_validation(...)
          let self._ncalls.post_validation += 1
          return {}
        endfunction
      End
      It should NOT call '_validate_required' if 'validate_required' is 0
        let parser.validate_required = 0
        Assert Equals(parser._ncalls._validate_required, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_required, 0)
      End
      It should call '_validate_required' if 'validate_required' is 1
        let parser.validate_required = 1
        Assert Equals(parser._ncalls._validate_required, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_required, 1)
      End
      It should NOT call '_validate_types' if 'validate_required' is 0
        let parser.validate_types = 0
        Assert Equals(parser._ncalls._validate_types, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_types, 0)
      End
      It should call '_validate_types' if 'validate_required' is 1
        let parser.validate_types = 1
        Assert Equals(parser._ncalls._validate_types, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_types, 1)
      End
      It should NOT call '_validate_conflicts' if 'validate_required' is 0
        let parser.validate_conflicts = 0
        Assert Equals(parser._ncalls._validate_conflicts, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_conflicts, 0)
      End
      It should call '_validate_conflicts' if 'validate_required' is 1
        let parser.validate_conflicts = 1
        Assert Equals(parser._ncalls._validate_conflicts, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_conflicts, 1)
      End
      It should NOT call '_validate_superordinates' if 'validate_required' is 0
        let parser.validate_superordinates = 0
        Assert Equals(parser._ncalls._validate_superordinates, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_superordinates, 0)
      End
      It should call '_validate_superordinates' if 'validate_required' is 1
        let parser.validate_superordinates = 1
        Assert Equals(parser._ncalls._validate_superordinates, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_superordinates, 1)
      End
      It should NOT call '_validate_dependencies' if 'validate_required' is 0
        let parser.validate_dependencies = 0
        Assert Equals(parser._ncalls._validate_dependencies, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_dependencies, 0)
      End
      It should call '_validate_dependencies' if 'validate_required' is 1
        let parser.validate_dependencies = 1
        Assert Equals(parser._ncalls._validate_dependencies, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_dependencies, 1)
      End
      It should NOT call '_validate_pattern' if 'validate_required' is 0
        let parser.validate_pattern = 0
        Assert Equals(parser._ncalls._validate_pattern, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_pattern, 0)
      End
      It should call '_validate_pattern' if 'validate_required' is 1
        let parser.validate_pattern = 1
        Assert Equals(parser._ncalls._validate_pattern, 0)
        call parser._validate_opts({})
        Assert Equals(parser._ncalls._validate_pattern, 1)
      End
    End
    Context ._validate_required({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'required': 1,
              \})
        call parser.add_argument('--bar', {
              \ 'alias': 'b',
              \ 'required': 1,
              \})
        call parser.add_argument('-H', {
              \})
        call parser.add_argument('piyo', {
              \ 'required': 1,
              \})
        call parser.add_argument('puyo', {
              \})
      End
      It should not raise any exceptions if all requirements are specified
        let opts = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \ 'bar': 'hello',
              \}
        call parser._validate_required(opts)
      End
      It should raise an exception if there are any missing requirements
        let opts = {
              \ 'foo': 1,
              \ 'H': 1,
              \}
        Throw parser._validate_required(opts), 'argument is required'
      End
    End
    Context ._validate_types({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'type': s:A.types.any,
              \})
        call parser.add_argument('--bar', {
              \ 'type': s:A.types.value,
              \})
        call parser.add_argument('--hoge', {
              \ 'type': s:A.types.switch,
              \})
        call parser.add_argument('--piyo', {
              \ 'type': s:A.types.choice,
              \ 'choices': ['a', 'b', 'c'],
              \})
      End
      It should not raise any exceptions if all arguments are correctly specified
        let opts = {
              \ 'foo': 1,
              \ 'bar': 'bar',
              \ 'hoge': 1,
              \ 'piyo': 'a',
              \}
        call parser._validate_types(opts)
      End
      It should raise an exception if no value is specified to VALUE argument
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \}
        Throw parser._validate_types(opts), 'argument is VALUE argument'
      End
      It should raise an exception if value is specified to SWITCH argument
        let opts = {
              \ 'foo': 1,
              \ 'bar': 'bar',
              \ 'hoge': 'hoge',
              \}
        Throw parser._validate_types(opts), 'argument is SWITCH argument'
      End
      It should raise an exception if no value is specified to CHOICE argument
        let opts = {
              \ 'piyo': 1,
              \}
        Throw parser._validate_types(opts), 'argument is CHOICE argument'
      End
      It should raise an exception if an invalid value is specified to CHOICE argument
        let opts = {
              \ 'piyo': 'hogehoge',
              \}
        Throw parser._validate_types(opts), 'argument is CHOICE argument'
      End
    End
    Context ._validate_conflicts({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'conflicts': ['bar', 'hoge'],
              \})
        call parser.add_argument('--bar', {
              \ 'conflicts': ['foo', 'hoge'],
              \})
        call parser.add_argument('--hoge', {
              \ 'conflicts': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \ 'conflicts': ['puyo'],
              \})
        call parser.add_argument('--puyo', {
              \ 'conflicts': ['piyo'],
              \})
      End
      It should not raise any exceptions if no conflicts found
        let opts = {
              \ 'foo': 1,
              \ 'piyo': 1,
              \}
        call parser._validate_conflicts(opts)
      End
      It should raise an exception if one of an argument conflict with another
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \}
        Throw parser._validate_conflicts(opts), 'argument conflicts with'
      End
    End
    Context ._validate_superordinates({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'superordinates': ['foo', 'bar'],
              \})
        call parser.add_argument('piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'superordinates': ['piyo'],
              \})
      End
      It should not raise any exceptions if one of superordinates is specified
        let opts = {
              \ 'foo': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        call parser._validate_superordinates(opts)
      End
      It should raise an exception if no superordinate is specified
        let opts = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        Throw parser._validate_superordinates(opts), 'No supoerordinate argument'
      End
    End
    Context ._validate_dependencies({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \})
        call parser.add_argument('--bar', {
              \})
        call parser.add_argument('--hoge', {
              \ 'dependencies': ['foo', 'bar'],
              \})
        call parser.add_argument('--piyo', {
              \})
        call parser.add_argument('--puyo', {
              \ 'dependencies': ['piyo'],
              \})
      End
      It should not raise any exception if all dependencies are exists
        let opts = {
              \ 'foo': 1,
              \ 'bar': 1,
              \ 'hoge': 1,
              \ 'piyo': 1,
              \ 'puyo': 1,
              \}
        call parser._validate_dependencies(opts)
      End
      It should raise an exception if any dependencies is missing
        let opts = {
              \ 'hoge': 1,
              \ 'puyo': 1,
              \}
        Throw parser._validate_dependencies(opts), 'argument is required for'
      End
    End
    Context ._validate_pattern({opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', {
              \ 'pattern': '\v^\d\d\d\-\d\d\d\d$'
              \})
      End
      It should not raise any exceptions if the value follow the specified pattern
        let opts = {
              \ 'foo': '000-0000',
              \}
        call parser._validate_types(opts)
      End
      It should raise an exception if the value does not follow the specified pattern
        let opts = {
              \ 'foo': '00-0000',
              \}
        Throw parser._validate_types(opts), 'argument is VALUE argument'
      End
    End

    Context .complete({arglead}, {cmdline}, {cursorpos}[, {opts}])
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'choices': ['foo', 'foobar', 'bar', 'hoge'] })
        call parser.add_argument('--bar', { 'choices': ['hello', 'good', 'bye'] })
        call parser.add_argument('good')
        call parser.add_argument('bye')
        let parser._ncalls = {
              \ '_parse_args': 0,
              \ '_complete_optional_argument_value': 0,
              \ '_complete_optional_argument': 0,
              \ '_complete_positional_argument_value': 0,
              \}
        function! parser._parse_args(...)
          let self._ncalls._parse_args += 1
          return {}
        endfunction
        function! parser._complete_optional_argument_value(...)
          let self._ncalls._complete_optional_argument_value += 1
        endfunction
        function! parser._complete_optional_argument(...)
          let self._ncalls._complete_optional_argument += 1
        endfunction
        function! parser._complete_positional_argument_value(...)
          let self._ncalls._complete_positional_argument_value += 1
        endfunction
      End
      It should call '_parse_args'
        let ncalls = parser._ncalls._parse_args
        call parser.complete('--foo=', '--foo=', [], {})
        Assert Equals(parser._ncalls._parse_args, ncalls + 1)
      End
      It should call '_complete_optional_argument_value' if '--foo=' is specified
        Assert Equals(parser._ncalls._complete_optional_argument_value, 0)
        call parser.complete('--foo=', '--foo=', [], {})
        Assert Equals(parser._ncalls._complete_optional_argument_value, 1)
      End
      It should call '_complete_optional_argument' if '--f' is specified
        Assert Equals(parser._ncalls._complete_optional_argument, 0)
        call parser.complete('--f', '--f', [], {})
        Assert Equals(parser._ncalls._complete_optional_argument, 1)
      End
      It should call '_complete_optional_argument' if 'f' is specified
        Assert Equals(parser._ncalls._complete_positional_argument_value, 0)
        call parser.complete('f', 'f', [], {})
        Assert Equals(parser._ncalls._complete_positional_argument_value, 1)
      End
    End
    Context ._complete_optional_argument_value({arglead}, {cmdline}, {cursorpos}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', { 'choices': ['foo', 'foobar', 'bar', 'hoge'] })
        call parser.add_argument('--bar', { 'choices': ['hello', 'good', 'bye'] })
      End
      It should return all posible candidates of a specified argument
        let candidates = parser._complete_optional_argument_value(
              \ '--foo=',
              \ '--foo=',
              \ [],
              \ { 'foo': '' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['foo', 'foobar', 'bar', 'hoge']),
              \)
      End
      It should return eliminated candidates of a specified argument if a part of value is specified
        let candidates = parser._complete_optional_argument_value(
              \ '--foo=fo',
              \ '--foo=',
              \ [],
              \ { 'foo': '' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['foo', 'foobar']),
              \)
      End
    End
    Context ._complete_optional_argument({arglead}, {cmdline}, {cursorpos}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo')
        call parser.add_argument('--foobar', { 'alias': 'f' })
        call parser.add_argument('--bar', { 'conflicts': ['hoge'] })
        call parser.add_argument('--hoge', { 'conflicts': ['bar'] })
        call parser.add_argument('--piyo')
        call parser.add_argument('--puyo', { 'superordinates': ['piyo'] })
        call parser.add_argument('hello')
      End
      It should return all posible arguments
        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { 'bar': 1 },
              \)
        " --bar is already specified thus not included
        " --hoge conflicts with --bar thus not included
        " --puyo require --piyo thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--piyo']),
              \)

        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { },
              \)
        " --puyo require --piyo thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--piyo', '--bar', '--hoge']),
              \)

        let candidates = parser._complete_optional_argument(
              \ '-',
              \ '-',
              \ [],
              \ { 'piyo': 1 },
              \)
        " --puyo is already specified thus not included
        " hello is positional thus not included
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar', '-f', '--puyo', '--bar', '--hoge']),
              \)
      End
      It should return eliminated arguments if a part of argument name is specified
        let candidates = parser._complete_optional_argument(
              \ '--fo',
              \ '--fo',
              \ [],
              \ {},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['--foo', '--foobar']),
              \)
      End
    End
    Context ._complete_positional_argument_value({arglead}, {cmdline}, {cursorpos}, {opts})
      Before
        let parser = s:A.new()
        call parser.add_argument('foo', { 'choices': ['aa', 'ab', 'ac', 'bb', 'bc', 'bd'] })
        call parser.add_argument('bar', { 'choices': ['e', 'f', 'g'] })
      End
      It should return all posible values of a corresponding positional argument
        let candidates = parser._complete_positional_argument_value(
              \ '',
              \ '',
              \ [],
              \ {},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['aa', 'ab', 'ac', 'bb', 'bc', 'bd']),
              \)

        let candidates = parser._complete_positional_argument_value(
              \ '',
              \ '',
              \ [],
              \ { 'foo': 'aa' },
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['e', 'f', 'g']),
              \)
      End
      It should return eliminated values if a part of positional argument value is specified
        let candidates = parser._complete_positional_argument_value(
              \ 'b',
              \ 'b',
              \ [],
              \ {'foo': 'b'},
              \)
        Assert Equals(
              \ sort(candidates),
              \ sort(['bb', 'bc', 'bd']),
              \)
      End
    End

    Context .help()
      Before
        let parser = s:A.new({ 'name': 'Foo', 'description': 'bar bar bar' })
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It should return a help
        let ret = parser.help()
        let exp = [
              \ ':Foo [alpha] beta [--foo] [--bar] [--hoge[=HOGE]] [--piyo=PIYO] [--puyo={PUYO}] [--[no-]papa] --mama',
              \ '',
              \ 'bar bar bar',
              \ '',
              \ 'Positional arguments:',
              \ '  alpha              alpha definition',
              \ '  beta               beta definition (*)',
              \ '',
              \ 'Optional arguments:',
              \ '      --foo          foo definition',
              \ '  -b, --bar          bar definition',
              \ '      --hoge[=HOGE]  hoge definition',
              \ '      --piyo=PIYO    piyo definition',
              \ '      --puyo={PUYO}  puyo definition',
              \ '      --[no-]papa    papa definition',
              \ '      --mama         mama definition (*)',
              \]
        Assert Equals(ret, join(exp, "\n"))
      End
    End
    Context ._help_optional_argument({arg})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It should return [{definition], {description}] list of a specified argument
        let ret = parser._help_optional_argument(parser.arguments['foo'])
        Assert Equals(ret[0], '    --foo')
        Assert Equals(ret[1], 'foo definition')

        let ret = parser._help_optional_argument(parser.arguments['bar'])
        Assert Equals(ret[0], '-b, --bar')
        Assert Equals(ret[1], 'bar definition')

        let ret = parser._help_optional_argument(parser.arguments['hoge'])
        Assert Equals(ret[0], '    --hoge[=HOGE]')
        Assert Equals(ret[1], 'hoge definition')

        let ret = parser._help_optional_argument(parser.arguments['piyo'])
        Assert Equals(ret[0], '    --piyo=PIYO')
        Assert Equals(ret[1], 'piyo definition')

        let ret = parser._help_optional_argument(parser.arguments['puyo'])
        Assert Equals(ret[0], '    --puyo={PUYO}')
        Assert Equals(ret[1], 'puyo definition')

        let ret = parser._help_optional_argument(parser.arguments['papa'])
        Assert Equals(ret[0], '    --[no-]papa')
        Assert Equals(ret[1], 'papa definition')

        let ret = parser._help_optional_argument(parser.arguments['mama'])
        Assert Equals(ret[0], '    --mama')
        Assert Equals(ret[1], 'mama definition (*)')
      End
    End
    Context ._help_positional_argument({arg})
      Before
        let parser = s:A.new()
        call parser.add_argument('--foo', 'foo definition')
        call parser.add_argument('--bar', '-b', 'bar definition')
        call parser.add_argument('--hoge', 'hoge definition', { 'type': s:A.types.any })
        call parser.add_argument('--piyo', 'piyo definition', { 'type': s:A.types.value })
        call parser.add_argument('--puyo', 'puyo definition', { 'choices': ['A', 'B', 'C'] })
        call parser.add_argument('--papa', 'papa definition', { 'deniable': 1 } )
        call parser.add_argument('--mama', 'mama definition', { 'required': 1 } )
        call parser.add_argument('alpha', 'alpha definition')
        call parser.add_argument('beta', 'beta definition', { 'required': 1 })
      End
      It should return [{definition], {description}] list of a specified argument
        let ret = parser._help_positional_argument(parser.arguments['alpha'])
        Assert Equals(ret[0], 'alpha')
        Assert Equals(ret[1], 'alpha definition')
        let ret = parser._help_positional_argument(parser.arguments['beta'])
        Assert Equals(ret[0], 'beta')
        Assert Equals(ret[1], 'beta definition (*)')
      End
    End
  End
End
